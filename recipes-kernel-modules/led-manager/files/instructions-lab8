Follow instructinos from here to create the kernel module, Do it with devtool, deplou and load

Beagle$ cd /lib/modules/6.1.46+/extra
insmod pmu-mod.ko


After insserting the module do:
cat /proc/devices



This looks like a good source for writing the laboratory
https://tldp.org/LDP/lkmpg/2.6/html/x569.html

=======================================

#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#define DRIVER_NAME "i2c_example"
#define I2C_SLAVE_ADDRESS 0x68

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("I2C Example Driver");
MODULE_VERSION("0.1");

static struct i2c_client *my_client;

static int i2c_example_read(struct i2c_client *client, u8 reg)
{
    s32 data;

    data = i2c_smbus_read_word_data(client, reg);
    if (data < 0) {
        dev_err(&client->dev, "Error reading register 0x%02x\n", reg);
        return data;
    }

    return data;
}

static ssize_t i2c_example_read_registers(struct file *file, char __user *buf, size_t count, loff_t *offset)
{
    int ret;
    u16 register_data[2];

    // Read from registers 0x22 and 0x23
    register_data[0] = i2c_example_read(my_client, 0x22);
    register_data[1] = i2c_example_read(my_client, 0x23);

    // Copy data to user space
    ret = copy_to_user(buf, register_data, sizeof(register_data));
    if (ret != 0) {
        return -EFAULT;
    }

    return sizeof(register_data);
}

static const struct file_operations i2c_example_fops = {
    .owner = THIS_MODULE,
    .read = i2c_example_read_registers,
};

static struct i2c_device_id i2c_example_id[] = {
    {DRIVER_NAME, 0},
    {}
};
MODULE_DEVICE_TABLE(i2c, i2c_example_id);

static struct of_device_id i2c_example_dt_ids[] = {
    { .compatible = "my,i2c-example", },
    {}
};
MODULE_DEVICE_TABLE(of, i2c_example_dt_ids);

static int i2c_example_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    struct device *dev = &client->dev;
    struct class *cls;
    struct device *dev_ret;
    int ret;

    dev_info(dev, "Probing I2C device at address 0x%02x\n", client->addr);

    // Initialize the file operations
    cdev_init(&my_cdev, &i2c_example_fops);
    ret = cdev_add(&my_cdev, MKDEV(0, 0), 1);
    if (ret < 0) {
        dev_err(dev, "Failed to add character device\n");
        return ret;
    }

    // Create a class
    cls = class_create(THIS_MODULE, DRIVER_NAME);
    if (IS_ERR(cls)) {
        dev_err(dev, "Failed to create class\n");
        cdev_del(&my_cdev);
        return PTR_ERR(cls);
    }

    // Create the device node
    dev_ret = device_create(cls, dev, MKDEV(0, 0), NULL, DRIVER_NAME);
    if (IS_ERR(dev_ret)) {
        dev_err(dev, "Failed to create device node\n");
        class_destroy(cls);
        cdev_del(&my_cdev);
        return PTR_ERR(dev_ret);
    }

    my_client = client;

    return 0;
}

static int i2c_example_remove(struct i2c_client *client)
{
    struct device *dev = &client->dev;

    dev_info(dev, "Removing I2C device at address 0x%02x\n", client->addr);

    // Destroy the device node
    device_destroy(my_cls, MKDEV(0, 0));

    // Destroy the class
    class_destroy(my_cls);

    // Remove the character device
    cdev_del(&my_cdev);

    return 0;
}

static struct i2c_driver i2c_example_driver = {
    .driver = {
        .name = DRIVER_NAME,
        .of_match_table = of_match_ptr(i2c_example_dt_ids),
    },
    .probe = i2c_example_probe,
    .remove = i2c_example_remove,
    .id_table = i2c_example_id,
};

module_i2c_driver(i2c_example_driver);


++++++++++++++++++++++

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "chardev-example"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A simple character kernel module");
MODULE_VERSION("0.1");

static int major_number;
static char message[256] = "Hello from the kernel!\n";
static int message_size = sizeof(message);

static int device_open(struct inode *inode, struct file *file)
{
    return 0;
}

static int device_release(struct inode *inode, struct file *file)
{
    return 0;
}

static ssize_t device_read(struct file *file, char __user *buffer, size_t length, loff_t *offset)
{
    if (*offset >= message_size)
        return 0;

    if (*offset + length > message_size)
        length = message_size - *offset;

    if (copy_to_user(buffer, message + *offset, length) != 0)
        return -EFAULT;

    *offset += length;
    return length;
}

static ssize_t device_write(struct file *file, const char __user *buffer, size_t length, loff_t *offset)
{
    if (copy_from_user(message, buffer, length) != 0)
        return -EFAULT;

    message_size = length;
    return length;
}

static struct file_operations fops = {
    .read = device_read,
    .write = device_write,
    .open = device_open,
    .release = device_release,
};

static int __init char_dev_init(void)
{
    major_number = register_chrdev(0, DEVICE_NAME, &fops);
    if (major_number < 0)
    {
        printk(KERN_ALERT "Failed to register a major number\n");
        return major_number;
    }

    printk(KERN_INFO "Registered correctly with major number %d\n", major_number);
    printk(KERN_INFO "'mknod /dev/%s c %d 0'.\n", DEVICE_NAME, major_number);
    return 0;
}

static void __exit char_dev_exit(void)
{
    unregister_chrdev(major_number, DEVICE_NAME);
    printk(KERN_INFO "Unregistered the character device\n");
}

module_init(char_dev_init);
module_exit(char_dev_exit);



=====================


/dts-v1/;
/plugin/;

/ {
    compatible = "my,i2c-example";
    model = "I2C Example Device";

    i2c@1 {
        #address-cells = <1>;
        #size-cells = <0>;
        compatible = "i2c-dev";
        reg = <1>;

        i2c-example@68 {
            compatible = "my,i2c-example";
            reg = <0x68>;
            status = "okay";
        };
    };
};
